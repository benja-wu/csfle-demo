package main

import (
	"context"
	"encoding/base64"
	"fmt"
	"log"
	"math/rand"
	"os"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

var (
	ctx = context.Background()
	// Test key material generated by: echo $(head -c 96 /dev/urandom | base64 | tr -d '\n')
	localMasterKey string
	kmsProviders   map[string]map[string]interface{}
)

func main() {
	client := createEncryptedClient()
	defer client.Disconnect(ctx)

	coll := client.Database("foo").Collection("bar")

	t := time.Now()
	r := rand.New(rand.NewSource(t.UnixNano()))
	min := 100000
	max := 300000
	random_str := fmt.Sprintf("%s_%d", "determinstic encrpytion", r.Intn(max-min+1)+min)
	fmt.Printf("before insert, prepare doc with plaintext_string: %s\n", random_str)
	fmt.Println()

	// Generate each part of the SSN
	part1 := rand.Intn(900) + 100   // 3 digits, 100–999
	part2 := rand.Intn(90) + 10     // 2 digits, 10–99
	part3 := rand.Intn(9000) + 1000 // 4 digits, 1000–9999

	// Format as "XXX-XX-XXXX"
	ssn := fmt.Sprintf("%03d-%02d-%04d", part1, part2, part3)
	// insert a document with an encrypted field and a plaintext field
	_, err := coll.InsertOne(ctx, bson.M{
		"plaintext_string": random_str,
		"plaintext_num":    2,
		"meta_info":        fmt.Sprintf("%s_%s", "hello world2", t.Format("2006-01-02 15:04:05")),
		"ssn":              ssn,
		"msg":              "encrpyted with deterministic type",
	})
	if err != nil {
		log.Fatalf("InsertOne error: %v", err)
	}
	fmt.Printf("insert successfully\n")
	fmt.Println()

	// find and print the inserted document
	fmt.Printf("after insert, query the doc with plaintext_string: %s\n", random_str)
	res := coll.FindOne(ctx, bson.M{"plaintext_string": random_str})
	raw, err := res.Raw()
	if err != nil {
		log.Fatalf("FindOne error: %v", err)
	}
	fmt.Println(raw)
	fmt.Println()

	fmt.Printf("after insert, query the doc with ssn: %s\n", ssn)
	res = coll.FindOne(ctx, bson.M{"ssn": ssn})
	raw, err = res.Raw()
	if err != nil {
		log.Fatalf("FindOne with SSN error: %v", err)
	}
	fmt.Println(raw)
}

// create a client configured with auto encryption that uses the key generated by createDataKey
func createEncryptedClient() *mongo.Client {
	// create a client with auto encryption

	localMasterKey = os.Getenv("LOCAL_MASTER_KEY")
	// initial setup
	decodedKey, err := base64.StdEncoding.DecodeString(localMasterKey)
	if err != nil {
		log.Fatalf("base64 decode error: %v", err)
	}
	kmsProviders = map[string]map[string]interface{}{
		"local": {"key": decodedKey},
	}

	schemaMap := map[string]interface{}{
		"foo.bar": readJSONFile("collection_schema_d.json"),
	}

	uri := os.Getenv("MONGODB_URI")

	autoEncOpts := options.AutoEncryption().
		SetKeyVaultNamespace("keyvault.datakeys").
		SetKmsProviders(kmsProviders).
		SetSchemaMap(schemaMap)

	clientOpts := options.Client().ApplyURI(uri).SetAutoEncryptionOptions(autoEncOpts)
	autoEncryptionClient, err := mongo.Connect(ctx, clientOpts)
	if err != nil {
		log.Fatalf("Connect error for client with automatic encryption: %v", err)
	}
	return autoEncryptionClient
}

func readJSONFile(file string) bson.D {
	content, err := os.ReadFile(file)
	if err != nil {
		log.Fatalf("ReadFile error for %v: %v", file, err)
	}

	var fileDoc bson.D
	if err = bson.UnmarshalExtJSON(content, false, &fileDoc); err != nil {
		log.Fatalf("UnmarshalExtJSON error for file %v: %v", file, err)
	}
	return fileDoc
}
