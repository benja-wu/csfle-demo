package main

import (
	"context"
	"encoding/base64"
	"fmt"
	"log"
	"math/rand/v2"
	"os"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

var (
	ctx = context.Background()
	// Test key material generated by: echo $(head -c 96 /dev/urandom | base64 | tr -d '\n')
	localMasterKey = "YOm8sMifl7BUJW8vEw4UGpGKtFDIooyat4DDTDmPI+og7PsERJZVE2ldsEanYN58HhUkl8LxLjjXRyc2ctQG/Gpjg8xUqAE1XwMgyXxYnwN7MnJYSC+0msDmyMybySny"
	kmsProviders   map[string]map[string]interface{}
)

func main() {
	// initial setup
	decodedKey, err := base64.StdEncoding.DecodeString(localMasterKey)
	if err != nil {
		log.Fatalf("base64 decode error: %v", err)
	}
	kmsProviders = map[string]map[string]interface{}{
		"local": {"key": decodedKey},
	}

	client := createEncryptedClient()
	defer client.Disconnect(ctx)

	coll := client.Database("foo").Collection("bar")

	// insert a document with an encrypted field and a plaintext field
	t := time.Now()
	min := 400000
	max := 900000
	random_str := fmt.Sprintf("%s_%d", ", random encrpytion", rand.IntN(max-min+1)+min)
	fmt.Printf("before insert, prepare doc with plaintext_string: %s\n", random_str)
	fmt.Println()

	ssn := bson.M{
		"ssn_num": "133-01-67899",
		"name":    "ben",
		"age":     35,
		"address": []string{"123 Main St, Apt 4B, NY", "456 Main St, Apt 4C, DC"},
	}

	_, err = coll.InsertOne(ctx, bson.M{
		"meta_info":        fmt.Sprintf("%s_%s", "hello world1", t.Format("2006-01-02 15:04:05")),
		"plaintext_string": random_str,
		"plaintext_num":    1,
		"ssn":              ssn,
		"altname":          "example",
		"msg":              "encrpyted in random type with sharded library",
	})
	if err != nil {
		log.Fatalf("InsertOne error: %v", err)
	}

	fmt.Printf("insert successfully\n")
	fmt.Println()

	// find and print the inserted document
	fmt.Printf("after insert, query the doc with plaintext_string: %s\n", random_str)
	res, err := coll.FindOne(ctx, bson.M{"plaintext_string": random_str}).DecodeBytes()
	if err != nil {
		log.Fatalf("FindOne error: %v", err)
	}
	fmt.Println(res)
}

// create a client configured with auto encryption that uses the key generated by createDataKey
func createEncryptedClient() *mongo.Client {
	cryptSharedLibraryPath := map[string]interface{}{
		"cryptSharedLibPath": os.Getenv("MDB_CRYPT_SHARED_LIB_PATH"), // Path to your Automatic Encryption Shared Library
	}

	uri := os.Getenv("MONGODB_URI")
	// create a client with auto encryption
	schemaMap := map[string]interface{}{
		"foo.bar": readJSONFile("collection_schema.json"),
	}
	autoEncOpts := options.AutoEncryption().
		SetKeyVaultNamespace("keyvault.datakeys").
		SetKmsProviders(kmsProviders).
		SetSchemaMap(schemaMap).
		SetExtraOptions(cryptSharedLibraryPath)

	clientOpts := options.Client().ApplyURI(uri).SetAutoEncryptionOptions(autoEncOpts)
	autoEncryptionClient, err := mongo.Connect(ctx, clientOpts)
	if err != nil {
		log.Fatalf("Connect error for client with automatic encryption: %v", err)
	}
	return autoEncryptionClient
}

func readJSONFile(file string) bson.D {
	content, err := os.ReadFile(file)
	if err != nil {
		log.Fatalf("ReadFile error for %v: %v", file, err)
	}

	var fileDoc bson.D
	if err = bson.UnmarshalExtJSON(content, false, &fileDoc); err != nil {
		log.Fatalf("UnmarshalExtJSON error for file %v: %v", file, err)
	}
	return fileDoc
}
